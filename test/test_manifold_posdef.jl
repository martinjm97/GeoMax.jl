n = 15
s = PositiveDefinite(n)

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)
@test size(x) == (n, n)

# Check symmetry
@test isapprox(x, multisym(x))

#TODO this
# Check positivity of eigenvalues
#l = la.eigvalsh(x)
#assert (l > [0]).all()

# TODO this
x = rand(s)
u = JManOpt.randvec(s, x)
#e = sp.linalg.expm(la.solve(x, u))

@test isapprox(multiprod(x, e), exp(s, x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = JManOpt.randvec(s, x)
v = JManOpt.randvec(s, x)
@test isapprox(multisym(u), u)
@test isapprox(1, man.norm(x, u))
@test vecnorm(u - v) > 1e-3

#--------------------------------
# Multidim Test
#--------------------------------
n = 10
k = 3
s = PositiveDefinite(n, k)

@test isapprox(JManOpt.dim(s), 0.5 * s.k * s.n * (s.n+1))

@test isapprox(JManOpt.typicaldist(s), sqrt(JManOpt.dim(s)))

x = rand(s)
y = rand(s)

# TODO this
# d = la.solve(x, y)
# for i in range(k):
#     d[i] = sp.linalg.logm(d[i])
#
# np_testing.assert_almost_equal(man.dist(x, y), la.norm(d))

x = rand(s)
a, b = randn(2, s.k, s.n, s.n)
@test isapprox(vecdot(a, b, JManOpt.inner(s, x, multiprod(x, a),multiprod(x, b)))

x = rand(s)
a = randn(s.k, s.n, s.n)
@test isapprox(JManOpt.proj(s, x, a), multisym(a))

x = rand()
u = randn(s.k, s.n, s.n)
@test isapprox(JManOpt.egrad2rgrad(s, x, u),multiprod(multiprod(x, multisym(u)), x))

x = rand(s)
egrad, ehess = randn(2, s.k, s.n, s.n)
u = JManOpt.randvec(s, x)

Hess = (multiprod(multiprod(x, multisym(ehess)), x) +
        2*multisym(multiprod(multiprod(u, multisym(egrad)), x)))

# Correction factor for the non-constant metric
Hess = Hess - multisym(multiprod(multiprod(u, multisym(egrad)), x))
@test isapprox(Hess, man.ehess2rhess(x, egrad, ehess,
                                                     u))
x = rand(s)
a = randn(s.k, s.n, s.n)
@test isapprox(vecnorm(a), JManOpt.norm(s, x, multiprod(x, a)))

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)

@test size(x) == (s.k, s.n, s.n)

# Check symmetry
@test isapprox(x, multisym(x))

# TODO This
# Check positivity of eigenvalues
#l = la.eigvalsh(x)
#assert (l > [[0]]).all()

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = JManOpt.randvec(s, x)
v = JManOpt.randvec(s, x)
@test isapprox(multisym(u), u)
@test isapprox(1, norm(s, x, u))
assert vecnorm(u - v) > 1e-3

x = rand(s)
y = rand(s)
u = JManOpt.randvec(s, x)
@test isapprox(JManOpt.transp(s, x, y, u), u)

# Test against manopt implementation, test that for small vectors
# exp(x, u) = x + u.
x = rand(s)
u = JManOpt.randvec(s, x)
e = zeros(s.k, s.n, s.n)

#TODO this
# for i in range(s.k):
#     e[i] = sp.linalg.expm(la.solve(x[i], u[i]))
# @test isapprox(multiprod(x, e), exp(x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Check that result is on manifold and for small vectors
# retr(x, u) = x + u.
u = JManOpt.randvec(s, x)
x = rand(s)
y = JManOpt.retr(s, x, u)

@test size(y) == (s.k, s.n, s.n)
# Check symmetry
@test isapprox(y, multisym(y))

# TODO this
# Check positivity of eigenvalues
# l = la.eigvalsh(y)
# assert (l > [[0]]).all()

u = u * 1e-6
@test isapprox(JManOpt.retr(s, x, u), x + u)

x = rand(s)
y = rand(s)
u = log(s, x, y)
@test isapprox(exp(s, x, u), y)

def test_log_exp_inverse(s):
x = rand(s)
u = JManOpt.randvec(s, x)
y = exp(s, x, u)
@test isapprox(log(s, x, y), u)
